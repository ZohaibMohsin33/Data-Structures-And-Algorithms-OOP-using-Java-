Objects are gonna store in heap memory 
while reference variables are gonna store in stack
Primitive data types also store only in stack memory

Access instance variables using . dot Operator or called separator
We can't manipulate memory addresses in java just like we do in c++ with pointers.
When the objects aren't initialized just declared, they are not gonna have some memory.
new keyword dynamically allots memory at runtime and return reference to it.
Dynamically memory allocation means ur program will got the memory when it is in running phase after the compilation work done totallly.


"Constructor basically tells what happens when u call an object"
Constructor don't have the return types.

Calling one constructor from another constructor can be done in polymorphism in this way.

Student (){

this ("one",2);
}

Class is just a logic. Actually object covers some space in memory

Note : we use final keyword in java to create a const type class or variable
Using the final keyword with the primitive data types so we can't change their values.
Using the final keyword with the non-primitive data types then we can't change the reference of the object but we're able to change the value of the object.

In cpp we use the destructors, but in java we use the finalization.........
we can't do manually obj.finalize this is done manually.

Video 2 : 

We can import a method or variable from the package of one file to another by just providing the path.
 We can only import the methods with the public access modifier.

import static com.work.b.repo.ClassName.methodName;

Qs what are static variables or method ?
Suppose, we have a class of human in which all the attributes are according to the person and changes person by person.
But at the same time our scientific name is same so we'll put scientific name as static keyword.

As you know to access the variables of the same class we use this operator 
But static variables are not directly related to the object so for that the convention is to use 
className.method for that
Human.population += 1;      It is good to go
this.population  += 1;      It's also good to go but not recommended

static variables or methods can be access without even creating the object of the specific class 
sout("ClassName.variableName")

this keyword is useless inside static methods

Inside static method you can only access static data, just like in example of the main you can only get those elements directly of the class those are static themselves 
u can have static methods insides a non-static that's not a problem.
you can't use this keyword inside of a static class.

To initialize the static variables we should use the static block
static int a = 4;
static int b;

static {
System.out.println("Hello") ;
b = a * 5;
}

Static block will only run once when the first object will be created.It is when the class is loaded for the first time.

InnerClasses:
This is like nested classes.
Outside classes can't be static while inner classes should be static because it's totally dependent on the outer class

Note : static methods or variables aren't dependent on object so they aren't deal in the run time they are deal in the compile time.

System.out.println('Hey babes');   
so here :
out is a final static variable

Video 3 :

Inheritance :

We use extends keyword for the purpose of inheritance
super() is used to call the parent constructor 

while we can use super() for the parent class also because internally it is also derieved from the Object Class.


class Child extends Base{  // Child class is inheriting from the Base class  }

Child class will not be able to access those members of the parent class, that has been declared private.


Parent obj = new Child();
this is valid but through this you can only access to parent variables because reference variable is derieved from the parent variable 
Note : It is the type of the reference variable that determines what variables of the objects to be called

Child obj = new Parent ();
this is invalid

For multilevel inheritence like A -> B -> C -> D

for using the super for D means we are talking about the C class for using the super in C means that we are referencing the B class vice versa.
Better to access the parent elements with super not with this just like    super.weight is for parent class variable and this.weight is for the own class variable
Initializing the super first and then initialize the other variables of the derieved class.

Most important : 

Child(Child box){
super(box) u r allowed to send box in the argument
}

Types of Inheritence :  

Single Inheritence 
Multilevel Inheritence
Multiple Inheritence        //Java doesn't supports it  //This thing is executed through interfaces
Hierarchial Inheritence  
Hybrid Inheritence         // Combination of single and multiple inheritence     //Java doesn't supports it also

Cyclic Inheritance isn't allowed i.e  class Box extends Box isn't possible technically

Polymorphism:
Poly means Many and Morphism means ways to represent
Types of Polymorphism 
1.Compile time/static polymorphism    ----> Achieved via method overloading     // operator overloading is not supported in java
Method overloading :

same names of methods but their parameteres or return types are different

2.Runtime / Dynamic Polymoriphism     ----> Achieved via method overridding
Method Overridding : 

Where a child class has the same name as the parent class 

@Override      ---> Is an annotation to check whether a method is overridden or not
you can't override a method that is provided as final

MOst Important :  Parent obj = new Child();
                  Which variables and methods are accessable depends upon Parent, what if there's a method overridden
                  which method will be called totally depends upon the chlid.

This is done by dynamic method dispatch, 
override is late binding 
while using final is early binding

If you don't want to inherit a class put a final keyword with it
If you define a class as final implicitly all of it's methods will be final also


Static Methods will not be override it will print the parent material always, even though the object is created of the child class.
Both overloading and overriding doesn't apply to instance variables

Encapsulation : 
Wrapping up the implementation of the data members and methods in a class.

Can be get by getters and setter and totally works on internal implementation or hidency

Abstraction : 
Hiding the unneccassary details and showing valuable information.

Can be get by abstract classes or interfaces.

Diff b/w data hidency and abstraction ?

Data hidency focuses on the data security while on the other hand encapsultion works on the 
hiding the complex implementations

Video 4 : 

Access Modifiers:

When u have added public it can be access from anywhere, when u have declared private it can be only accessed within the class.
When there's no access modifier specified it means that it is default 

Default access modifier means variables can be called anywhere within the same pakage, but if it is called to 
another pakage then it'll be in trouble.
See the picture in the folder

1.User Defined Pakages 2. In-build pakages

In-build pakages:

1. Lang                     (Contains essentials of the java language specific stuff) //It's automatically imported. We use it without importing.
2. IO (input output)    
3. Util (utility classes)   (Data Structures and stuff)
4. Applet 
5. Awt                      (Used to create GUI applications)
6. Net
 
Note : By default every class is extending the object class.
Here we are going to disscuss some of the overriding methods

@Override 
public String toString(){
return super.toString();              basically gives the string representation
}

@Override 
protected void finalize() throws Throwable{
super.finalize();                     basically code runs when the garbage collector hits
}

@Override
public int hashCode (){
   return super.hashCode();            gives number representation of an object, it's a random integer value which is created to mark an object as unique
}

simple to above one few overriding methods are 

@Override 
public boolean equals (Object obj){
return super.equals(obj);
}

@Override 
protected Object clone() throws CloneNotSupportedException{
return super.clone();
}

Instance of :

System.out.println(obj instanceof A);        It'll print true or false //It will print true if object is instance of some derieved class of A
System.out.println(obj1.getClass());         .getClass().getName()

getClass() data stores in the heap we can find other stuff by using the dot operator with the getClass method
